TOPIC 1: STRUCTURES âœ…
Clear Explanation:
A structure is a composite data type in C that allows you to group variables of different types under a single name. It's the foundation for organizing related data.

Practical Examples:
Example 1: Simple Student Structure

C
#include <stdio.h>

struct Student {
    int roll_no;
    char name[50];
    float gpa;
};

int main() {
    struct Student s1;
    s1.roll_no = 101;
    printf("GPA: %.2f\n", s1.gpa);
    return 0;
}
Example 2: Employee Structure

C
struct Employee {
    int emp_id;
    char name[100];
    float salary;
    int years_experience;
};
Example 3: Date Structure

C
struct Date {
    int day;
    int month;
    int year;
};
Usage Guidelines:
Use struct keyword to declare
Access members with dot (.) operator
Use -> operator with pointers
Useful for organizing related data
Pass entire structure to functions
Quick Reference:
C
// Declaration
struct StructName {
    int member1;
    float member2;
};

// Usage
struct StructName var;
var.member1 = 10;
Nested Structures Example:
C
struct Address {
    char street[100];
    char city[50];
};

struct Person {
    char name[100];
    struct Address address;  // Nested
};
Arrays of Structures:
C
struct Student students[100];
students[0].roll_no = 1;
TOPIC 2: UNIONS âœ…
Clear Explanation:
A union is similar to a structure, but all members share the same memory location. Only one member can hold a value at any time.

Key Differences:
Feature	Structure	Union
Memory	Each member gets own space	All share same space
Size	Sum of all members	Size of largest
Independent	All can have values	Only one at a time
Use Case	Related data	Memory-efficient storage
Practical Examples:
Example 1: Basic Union

C
#include <stdio.h>

union Data {
    int intValue;
    float floatValue;
    char charValue;
};

int main() {
    union Data data;
    printf("Size: %lu\n", sizeof(union Data));  // 4 bytes
    
    data.intValue = 100;
    printf("Int: %d\n", data.intValue);
    
    data.floatValue = 3.14;  // Overwrites intValue
    printf("Float: %.2f\n", data.floatValue);
    printf("Int now: %d\n", data.intValue);  // Garbage
    
    return 0;
}
Example 2: Device Control Union

C
union DeviceControl {
    unsigned char byte;
    struct {
        unsigned int bit0 : 1;
        unsigned int bit1 : 1;
        unsigned int bit2 : 1;
    } bits;
};
Example 3: Union for Flexible Data Storage

C
union Number {
    int intVal;
    float floatVal;
    double doubleVal;
};
Usage Guidelines:
Use only when memory is critical
Document which member is active
Useful for hardware programming
Avoid mixing types unnecessarily
Provides memory-efficient storage
Quick Reference:
C
// Declaration
union UnionName {
    int member1;
    float member2;
};

// Usage
union UnionName var;
var.member1 = 10;  // Allocates 4 bytes total
var.member2 = 3.14;  // Overwrites member1
When to Use Unions:
Hardware registers
Embedded systems
Bit manipulation
Memory-constrained devices
TOPIC 3: TYPEDEF âœ…
Clear Explanation:
typedef creates an alias for an existing data type, making code more readable and maintainable. It simplifies complex type declarations.

Basic Syntax:
C
typedef existing_type new_name;
Practical Examples:
Example 1: Primitive Types

C
typedef int Integer;
typedef float Real;
typedef char Character;

int main() {
    Integer count = 100;
    Real price = 99.99;
    return 0;
}
Example 2: Typedef with Structures

C
typedef struct {
    int id;
    char name[50];
    float salary;
} Employee;

// Without typedef: struct Employee emp1;
// With typedef: Employee emp1;
Example 3: Typedef with Pointers

C
typedef int* IntPointer;
typedef float* FloatPointer;

int main() {
    int x = 10;
    IntPointer ptr = &x;
    printf("%d\n", *ptr);
    return 0;
}
Example 4: Typedef with Arrays

C
typedef int IntArray[10];
typedef float Marks[5];

int main() {
    IntArray arr = {1, 2, 3};
    Marks student_marks = {85, 90, 78};
    return 0;
}
Example 5: Typedef with Unions

C
typedef union {
    int intVal;
    float floatVal;
} DataValue;

int main() {
    DataValue data;
    data.intVal = 100;
    return 0;
}
Example 6: Function Pointers

C
typedef int (*MathFunc)(int, int);

int add(int a, int b) {
    return a + b;
}

int main() {
    MathFunc operation = add;
    printf("%d\n", operation(10, 5));  // 15
    return 0;
}
Usage Guidelines:
Use meaningful names
Hide platform-specific types
Simplify complex declarations
Improve code readability
Use consistently throughout project
Quick Reference:
C
// Primitives
typedef int INT;

// Structures
typedef struct { int x; } Point;

// Arrays
typedef int IntArray[100];

// Pointers
typedef int* IntPtr;
Advantages:
More readable code
Easier to maintain
Platform independence
Simplified declarations
Better consistency
TOPIC 4: ENUMERATIONS âœ…
Clear Explanation:
An enumeration defines a set of named integer constants. It provides a type-safe way to work with sets of related constants.

Basic Syntax:
C
enum EnumName {
    CONSTANT1,  // 0
    CONSTANT2,  // 1
    CONSTANT3   // 2
};
Practical Examples:
Example 1: Color Enumeration

C
#include <stdio.h>

enum Color {
    RED,
    GREEN,
    BLUE,
    YELLOW,
    BLACK
};

int main() {
    enum Color myColor = GREEN;
    printf("Color value: %d\n", myColor);  // 1
    return 0;
}
Example 2: Traffic Light with Switch

C
enum TrafficLight {
    RED = 1,
    YELLOW = 2,
    GREEN = 3
};

void displayLight(enum TrafficLight light) {
    switch(light) {
        case RED:
            printf("Stop!\n");
            break;
        case YELLOW:
            printf("Prepare!\n");
            break;
        case GREEN:
            printf("Go!\n");
            break;
    }
}
Example 3: Days of Week

C
enum Day {
    MONDAY = 1,
    TUESDAY = 2,
    WEDNESDAY = 3,
    THURSDAY = 4,
    FRIDAY = 5,
    SATURDAY = 6,
    SUNDAY = 7
};

const char* getDayName(enum Day day) {
    const char* names[] = {
        "", "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday", "Sunday"
    };
    return names[day];
}
Example 4: Size Options

C
enum Size {
    SMALL,
    MEDIUM,
    LARGE,
    EXTRA_LARGE
};

float getPrice(enum Size size) {
    switch(size) {
        case SMALL: return 5.99;
        case MEDIUM: return 7.99;
        case LARGE: return 9.99;
        case EXTRA_LARGE: return 12.99;
    }
    return 0.0;
}
Example 5: Custom Values

C
enum ErrorCode {
    SUCCESS = 0,
    FILE_NOT_FOUND = 404,
    PERMISSION_DENIED = 403,
    SERVER_ERROR = 500
};
Example 6: Typedef with Enum

C
typedef enum {
    ACTIVE,
    INACTIVE,
    SUSPENDED
} Status;

typedef struct {
    int id;
    Status status;
} Account;
Usage Guidelines:
Use instead of #define for constants
Provide meaningful names
Keep related values together
Useful with switch statements
Type-safe alternative to integers
Quick Reference:
C
// Basic enum
enum Color { RED, GREEN, BLUE };

// Custom values
enum Status { ACTIVE = 1, INACTIVE = 0 };

// Typedef enum
typedef enum { ON, OFF } Switch;

// Using
enum Color c = RED;
printf("%d\n", c);  // 0
Advantages:
Self-documenting code
Type checking by compiler
Cleaner switch statements
Better than magic numbers
Easier to maintain
ðŸ“Š QUICK REFERENCE TABLE
Concept	Purpose	Size	Use Case
Structure	Group multiple types	Sum of members	Store related data
Union	Share memory space	Largest member	Memory-efficient storage
Typedef	Create type alias	Same as original	Readability & simplification
Enum	Named constants	int (4 bytes)	Define options/states
COMPARISON TABLE: WHEN TO USE EACH
Situation	Use	Example
Store student details	Structure	Name, ID, GPA together
Hardware register control	Union	Device status bits
Simplify pointer declarations	Typedef	typedef int* IntPtr;
Define status values	Enumeration	ACTIVE, INACTIVE, SUSPENDED
Flexible data storage	Union	Store one of several types
Complex type alias	Typedef	Function pointers, arrays
Named options	Enum	Colors, Days, Status
âœ… BEST PRACTICES SUMMARY
Structures:
âœ… Use meaningful member names
âœ… Keep related data together
âœ… Document structure purpose
âœ… Consider memory alignment
âœ… Use typedef for convenience
Unions:
âœ… Use only when memory is critical
âœ… Document which member is active
âœ… Avoid unnecessary mixing
âœ… Useful for hardware programming
âœ… Be careful with type casting
Typedef:
âœ… Create aliases for complex types
âœ… Use consistent naming
âœ… Don't overuse (avoid confusion)
âœ… Helps with code portability
âœ… Simplify declarations
Enumerations:
âœ… Use instead of #define
âœ… Group related values
âœ… Provide meaningful names
âœ… Use with switch statements
âœ… Type-safe constants
COMBINED EXAMPLE: Using All Four
C
#include <stdio.h>

// Enumeration
typedef enum {
    STUDENT,
    TEACHER,
    ADMIN
} Role;

// Union for flexible storage
typedef union {
    int student_id;
    int employee_id;
} ID;

// Structure combining everything
typedef struct {
    char name[50];
    Role role;
    ID id;
    float salary;
} Person;

void displayPerson(Person p) {
    printf("Name: %s\n", p.name);
    printf("Role: %d\n", p.role);
    
    switch(p.role) {
        case STUDENT:
            printf("Student ID: %d\n", p.id.student_id);
            break;
        case TEACHER:
            printf("Salary: $%.2f\n", p.salary);
            break;
    }
}

int main() {
    Person student = {"Alice", STUDENT, {.student_id = 1001}, 0};
    Person teacher = {"Mr. Smith", TEACHER, {.employee_id = 2001}, 50000};
    
    displayPerson(student);
    displayPerson(teacher);
    
    return 0;
}
ðŸ“ˆ Learning Progression
Start with Structures - Learn to group data
Add Unions - Understand memory sharing
Apply Typedef - Simplify declarations
Use Enumerations - Define meaningful constants
Combine All - Build complex applications
ðŸŽ¯ Summary
Unit-I provides the foundation for composite data types:

âœ… Structures - Organize related data âœ… Unions - Memory-efficient storage âœ… Typedef - Create readable type aliases âœ… Enumerations - Define named constants

These concepts enable you to:

Write organized, readable code
Create custom data types
Manage memory efficiently
Build maintainable applications
Improve code clarity
